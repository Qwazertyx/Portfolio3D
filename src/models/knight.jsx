/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: Dasha Klyusova (https://sketchfab.com/AnoFail)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/hollow-knight-5a76d93e39984f829abd6f406562265b
Title: Hollow Knight
*/


import React, { useRef, useEffect } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber'
import { a } from '@react-spring/three'

import knightscene from '../assets/hollow_knight/public/hollow_knight.glb'; //

const Knight = ({isRotating, setIsRotating, setCurrentStage, ...props}) => {
	const knightRef = useRef();

	const { gl, viewport } = useThree();
	const { nodes, materials } = useGLTF(knightscene)

	const lastX = useRef(0);
	const rotationSpeed = useRef(0);
	const dampingFactor = 0.95;

	/* e for event 
	security *2 + rotate*/
	const handlePointerDown = (e) => { 
		e.stopPropagation();
		e.preventDefault();
		setIsRotating(true);

		const clientX = e.touches ? e.touches[0].clientX : e.clientX;
		lastX.current = clientX;
	}
	const handlePointerUp = (e) => {
		e.stopPropagation();
		e.preventDefault();
		setIsRotating(false);

	}
	const handlePointerMove = (e) => {
		e.stopPropagation();
		e.preventDefault();

		if(isRotating){
			const clientX = e.touches ? e.touches[0].clientX : e.clientX;
			const delta = (clientX - lastX.current) / viewport.width;
			knightRef.current.rotation.y += delta * Math.PI * 0.05;
	
			lastX.current = clientX;
			rotationSpeed.current = delta * Math.PI * 0.05;
		}

	}

	const handleKeyDown = (e) => {
		if(e.key === 'ArrowLeft'){
			if (!isRotating) setIsRotating(true);
				knightRef.current.rotation.y += Math.PI * 0.05;
		}
		else if(e.key === 'ArrowRight'){
			if (!isRotating) setIsRotating(true);
				knightRef.current.rotation.y -= Math.PI * 0.05;
		}
	}

	const handleKeyUp = (e) => {
		if(e.key === 'ArrowLeft' || e.key === 'ArrowRight'){
			setIsRotating(false);
		}
	}

	useFrame(() => {
		// If not rotating, apply damping to slow down the rotation (smoothly)
		if (!isRotating) {
		  rotationSpeed.current *= dampingFactor;
		  // Stop rotation when speed is very small
		  if (Math.abs(rotationSpeed.current) < 0.001) {
			rotationSpeed.current = 0;
		  }
		  knightRef.current.rotation.y += rotationSpeed.current;
		} else {
		  // When rotating, determine the current stage based on island's orientation
		  const rotation = knightRef.current.rotation.y;
		  const normalizedRotation =
			((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
	
		  // Set the current stage based on the island's orientation
		  switch (true) {
			case normalizedRotation >= 5.45 && normalizedRotation <= 5.85:
			  setCurrentStage(4);
			  break;
			case normalizedRotation >= 0.85 && normalizedRotation <= 1.3:
			  setCurrentStage(3);
			  break;
			case normalizedRotation >= 2.4 && normalizedRotation <= 2.6:
			  setCurrentStage(2);
			  break;
			case normalizedRotation >= 4.25 && normalizedRotation <= 4.75:
			  setCurrentStage(1);
			  break;
			default:
			  setCurrentStage(null);
		  }
		}
	  });

	useEffect(() => {
		const canvas = gl.domElement;
		canvas.addEventListener('pointerdown', handlePointerDown);
		canvas.addEventListener('pointerup', handlePointerUp);
		canvas.addEventListener('pointermove', handlePointerMove);
		document.addEventListener('keydown', handleKeyDown);
		document.addEventListener('keyup', handleKeyUp);

		return () => {
			canvas.removeEventListener('pointerdown', handlePointerDown);
			canvas.removeEventListener('pointerup', handlePointerUp);
			canvas.removeEventListener('pointermove', handlePointerMove);
			document.removeEventListener('keydown', handleKeyDown);
			document.removeEventListener('keyup', handleKeyUp);
		}
	}, [gl, handlePointerDown, handlePointerUp, handlePointerMove]);

	return (
	  <a.group ref ={knightRef} {...props} >
	    <group rotation={[-Math.PI / 2, 0, 0]} scale={0.068}>
	      <mesh
	        geometry={nodes.Object_2.geometry}
	        material={materials['null']}
	      />
	      <mesh
	        geometry={nodes.Object_3.geometry}
	        material={materials['None.001']}
	      />
	    </group>
	  </a.group>
	)
}

export default Knight;
